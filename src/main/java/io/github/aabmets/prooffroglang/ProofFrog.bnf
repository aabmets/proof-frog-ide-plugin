{
    parserClass="io.github.aabmets.prooffroglang.parser.ProofFrogParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
    psiClassPrefix="ProofFrog"
    psiImplClassSuffix="Impl"
    psiPackage="io.github.aabmets.prooffroglang.psi"
    psiImplPackage="io.github.aabmets.prooffroglang.psi.impl"
    elementTypeHolderClass="io.github.aabmets.prooffroglang.psi.ProofFrogTypes"
    elementTypeClass="io.github.aabmets.prooffroglang.psi.ProofFrogElementType"
    tokenTypeClass="io.github.aabmets.prooffroglang.psi.ProofFrogTokenType"
}

file ::= (
    primitiveProgram |
    schemeProgram |
    gameProgram |
    proofProgram |
    VL_LINE_COMMENT
);


// Primitive files grammar
primitiveProgram ::=
    FN_PRIMITIVE VL_IDENT ST_PAREN_L paramList? ST_PAREN_R
    ST_BRACE_L primitiveBody ST_BRACE_R
    ;
primitiveBody ::= ((initializedField | methodSignature) PN_SEMI)*;


// Scheme files grammar
schemeProgram ::= moduleImport* scheme;
scheme ::=
    FN_SCHEME VL_IDENT ST_PAREN_L paramList? ST_PAREN_R
    KW_EXTENDS VL_IDENT ST_BRACE_L schemeBody ST_BRACE_R
    ;
schemeBody ::=
    (KW_REQUIRES expression PN_SEMI)*
    (field PN_SEMI | method)+
    ;

// Game files grammar
gameProgram ::= moduleImport* game game gameExport;
gameExport ::= KW_EXPORT KW_AS VL_IDENT PN_SEMI;


// Proof files grammar
proofProgram ::= moduleImport* proofHelpers proof;
proofHelpers ::= (reduction | game)*;
reduction ::=
    FN_REDUCTION VL_IDENT ST_PAREN_L paramList? ST_PAREN_R
    KW_COMPOSE parameterizedGame KW_AGAINST gameAdversary
    ST_BRACE_L gameBody ST_BRACE_R
    ;
proof ::=
    KW_PROOF PN_COLON
    (KW_LET PN_COLON lets)?
    (KW_ASSUME PN_COLON assumptions)?
    KW_THEOREM PN_COLON theorem
    KW_GAMES PN_COLON gameList
    ;
lets ::= (field PN_SEMI)*;
assumptions ::= (parameterizedGame PN_SEMI)* (KW_CALLS (OP_LEQ | OP_LT) expression PN_SEMI)?;
theorem ::= parameterizedGame PN_SEMI;
gameList ::= gameStep PN_SEMI (gameStep PN_SEMI | induction | stepAssumption)*;
gameStep ::=
    concreteGame KW_COMPOSE parameterizedGame KW_AGAINST gameAdversary |  // reductionStep
	(concreteGame | parameterizedGame) KW_AGAINST gameAdversary            // regularStep
	;
induction ::=
    KW_INDUCTION ST_PAREN_L VL_IDENT KW_FROM integerExpression KW_TO
    integerExpression ST_PAREN_R ST_BRACE_L gameList ST_BRACE_R
    ;
stepAssumption ::= KW_ASSUME expression PN_SEMI;
concreteGame ::= parameterizedGame PN_PERIOD VL_IDENT;
gameAdversary ::= parameterizedGame PN_PERIOD FN_ADVERSARY;


// Shared grammar

moduleImport ::= KW_IMPORT VL_FILESTRING (KW_AS VL_IDENT)? PN_SEMI;

game ::= FN_GAME VL_IDENT ST_PAREN_L paramList? ST_PAREN_R ST_BRACE_L gameBody ST_BRACE_R;

gameBody ::=
    (field PN_SEMI)* method+ |
    (field PN_SEMI)* method* gamePhase+
    ;

gamePhase ::=
    FN_PHASE ST_BRACE_L (method)+ KW_ORACLES PN_COLON
    ST_BRACKET_L id (PN_COMMA id)* ST_BRACKET_R PN_SEMI ST_BRACE_R
    ;

field ::= variable (OP_ASSIGN expression)?;

initializedField ::= variable OP_ASSIGN expression;

method ::= methodSignature block;

block ::= ST_BRACE_L statement* ST_BRACE_R;

statement ::=
      type id PN_SEMI                                             // varDeclStatement
	| type lvalue OP_ASSIGN expression PN_SEMI                       // varDeclWithValueStatement
	| type lvalue OP_SAMPLE expression PN_SEMI                       // varDeclWithSampleStatement
	| lvalue OP_ASSIGN expression PN_SEMI                            // assignmentStatement
	| lvalue OP_SAMPLE expression PN_SEMI                            // sampleStatement
	| expression ST_PAREN_L argList? ST_PAREN_R PN_SEMI             // functionCallStatement
	| KW_RETURN expression PN_SEMI                                 // returnStatement
	| KW_IF ST_PAREN_L expression ST_PAREN_R block (KW_ELSE KW_IF ST_PAREN_L expression ST_PAREN_R block )* (KW_ELSE block )?  // ifStatement
	| KW_FOR ST_PAREN_L DT_INT id OP_ASSIGN expression KW_TO expression ST_PAREN_R block  // numericForStatement
	| KW_FOR ST_PAREN_L type id KW_IN expression ST_PAREN_R block     // genericForStatement
	;

lvalue ::= (id | parameterizedGame) (PN_PERIOD id | ST_BRACKET_L expression ST_BRACKET_R)*;

methodSignature ::= type id ST_PAREN_L paramList? ST_PAREN_R;

paramList ::= variable (PN_COMMA variable)*;

expression ::= setMinusExpression ;
setMinusExpression ::= unionExpression (OP_BSLASH unionExpression)*;
unionExpression ::= orExpression (KW_UNION orExpression)*;
orExpression ::= andExpression (OP_OR andExpression)*;
andExpression ::= comparisonExpression (OP_AND comparisonExpression)*;
comparisonExpression ::= addExpression (
    (OP_EQ | OP_NEQ | OP_GT | OP_LT | OP_GEQ | OP_LEQ | KW_IN | KW_SUBSETS)
    addExpression
)?;
addExpression ::= multiplyExpression ( (OP_ADD | OP_SUB) multiplyExpression )*;
multiplyExpression ::= unaryExpression ( (OP_MULT | OP_DIV) unaryExpression )*;
unaryExpression ::=
      OP_NOT unaryExpression
    | OP_VBAR unaryExpression OP_VBAR
    | primaryExpression
    ;
primaryExpression ::= primaryElement (postfixOperation)*;
primaryElement ::=
      lvalue
    | ST_BRACKET_L (expression (PN_COMMA expression)*)? ST_BRACKET_R
    | ST_BRACE_L  (expression (PN_COMMA expression)*)? ST_BRACE_R
    | type
    | VL_BINARYNUM
    | DT_INT
    | VL_BOOL
    | KW_NONE
    | ST_PAREN_L expression ST_PAREN_R
    ;
postfixOperation ::=
      ST_PAREN_L argList? ST_PAREN_R
    | ST_BRACKET_L integerExpression PN_COLON integerExpression ST_BRACKET_R
    ;

argList ::= expression (PN_COMMA expression)*;

variable ::= type id;

parameterizedGame ::= VL_IDENT ST_PAREN_L argList? ST_PAREN_R;

type ::= typeProduct ;
typeProduct ::= typePostfix (OP_MULT typePostfix)*;
typePostfix ::= atomicType OP_OPT*;
atomicType ::=
      DT_SET OP_LT type OP_GT
    | DT_SET
    | DT_BOOL
    | DT_VOID
    | DT_MAP OP_LT type PN_COMMA type OP_GT
    | DT_ARRAY OP_LT type PN_COMMA integerExpression OP_GT
    | DT_INT
    | DT_BITSTRING OP_LT integerExpression OP_GT
    | DT_BITSTRING
    | lvalue
    ;

integerExpression ::= additiveIntegerExpression ;
additiveIntegerExpression ::=
      multiplicativeIntegerExpression
    ( (OP_ADD | OP_SUB) multiplicativeIntegerExpression )*
    ;
multiplicativeIntegerExpression ::=
      primaryIntegerExpression
    ( (OP_MULT | OP_DIV) primaryIntegerExpression )*
    ;
primaryIntegerExpression ::=
      lvalue
    | VL_INT
    | VL_BINARYNUM
    | ST_PAREN_L integerExpression ST_PAREN_R
    ;

id ::= VL_IDENT | KW_IN;
